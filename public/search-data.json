[
  {
    "id": "api/built-in-components",
    "title": "Built-in Components Reference",
    "content": "Built-in Components [The Toolbox] Muni provides a set of powerful components that are globally available in all your MDX files. These are designed to help you create rich, structured content without needing to import them. Callouts Callouts are used to highlight a block of text. They are created using the  container directive. - Directive:  - Supported Types: , , ,  Steps The  component creates an ordered, numbered list of steps, perfect for tutorials. It automatically numbers any  heading within it. - Directive:  CodeGroup A component for displaying multiple code blocks in a tabbed view. - Directive:  ts [TypeScript] const message: string = \"Hello\"; js [JavaScript] const message = \"Hello\"; Aside<Aside>",
    "url": "/docs/api/built-in-components",
    "tags": []
  },
  {
    "id": "api/configuration",
    "title": "Configuration Reference",
    "content": "Configuration [The Control Panel] Configuration for a Muni project is handled in two main places:  for site-specific settings like navigation, and  for the underlying MDX and Next.js behavior. This is the primary configuration file for your site's content and navigation. It exports a  object.  Interface - Type:  - Description: The main title of your documentation site. It's used in the browser tab, metadata, and can be used in your site header. - Type:  (optional) - Description: A version string for your project, which is displayed in the site header. - Type:  (optional) - Default:  - Description: Whether to display the author and date from the frontmatter at the bottom of each page. - Type:  (optional) - Description: An array of link objects to be displayed in the site header, next to the version. - Type:  - Description: An array of objects that defines the structure of your sidebar navigation. Each  has the following properties: -  (string): The text displayed in the navigation sidebar. -  (string): The URL slug for the page. This must match the file path in  (without the  extension). For the homepage, use . -  (optional ): An optional array of nested navigation items to create collapsible sections in the sidebar. Example Configuration This file controls the Next.js build process, including how MDX files are handled. Muni comes with a pre-configured set of Remark and Rehype plugins to add advanced features to your Markdown. Default Plugins Muni's default configuration includes plugins for: - GFM (GitHub Flavored Markdown): Adds support for tables, strikethroughs, etc. - Frontmatter: Parses the YAML frontmatter from your files. - Code Block Titles: Adds titles to code blocks. - Callouts: Enables  directives for callouts. - Steps: Enables the  component. - Slug & Autolink Headings: Automatically adds s to headings and links them. Customizing Plugins You can add your own Remark or Rehype plugins by modifying the  object in .",
    "url": "/docs/api/configuration",
    "tags": []
  },
  {
    "id": "api/frontmatter",
    "title": "Frontmatter Reference",
    "content": "Frontmatter Reference [Page Metadata] Frontmatter is the YAML block at the top of your MDX files, enclosed by triple dashes (). It allows you to provide metadata for each page. Standard Properties These are the primary properties that Muni uses to control page rendering and SEO. -   Type:  -   Required:  -   Description: The main title of the page. It is displayed at the top of the page content and used in the browser tab title (). -   Type:  -   Required:  -   Description: A brief summary of the page content. This is critical for SEO as it is used for the  tag, and it also powers the text snippets in the site's search results. Custom Properties You can add any other custom properties to your frontmatter. These properties are not used by Muni out-of-the-box, but they can be accessed from your own custom components or during the build process. Example with Custom Metadata Accessing Custom Frontmatter While Muni doesn't use custom frontmatter directly, you can configure your project to read it. For example, you could create a custom component that reads the  and  from the page's frontmatter. This typically requires customizing the MDX loader or creating a wrapper component that has access to the page's metadata. The frontmatter is available to the page layout component.",
    "url": "/docs/api/frontmatter",
    "tags": []
  },
  {
    "id": "api",
    "title": "API Reference",
    "content": "API Reference [Technical Details] This section provides a detailed technical reference for the key APIs and configuration surfaces in Muni. Use these guides to understand all the available options for customizing and extending your documentation site. Reference Documents <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\"> <a href=\"/docs/api/configuration\" className=\"border p-4 rounded-lg hover:bg-accent\">   <h3 class=\"font-semibold text-lg mb-2\">Configuration</h3>   <p class=\"text-sm text-muted-foreground\">Explore all the options available in the  and  files.</p> </a> <a href=\"/docs/api/frontmatter\" className=\"border p-4 rounded-lg hover:bg-accent\">   <h3 class=\"font-semibold text-lg mb-2\">Frontmatter</h3>   <p class=\"text-sm text-muted-foreground\">A complete reference for all the standard and custom frontmatter properties you can use in your MDX files.</p> </a> <a href=\"/docs/api/built-in-components\" className=\"border p-4 rounded-lg hover:bg-accent\">   <h3 class=\"font-semibold text-lg mb-2\">Built-in Components</h3>   <p class=\"text-sm text-muted-foreground\">A detailed look at the props and usage of all the globally available components like  and .</p> </a> </div>",
    "url": "/docs/api",
    "tags": []
  },
  {
    "id": "components-showcase",
    "title": "Components Showcase",
    "content": "Components Showcase This page demonstrates all the available MDX components in the Muni documentation system. Callouts and Info Boxes Callout Component <Callout type=\"info\">   This is an info callout with some important information. </Callout> <Callout type=\"warning\" title=\"Important\">   This is a warning callout with a custom title. </Callout> <Callout type=\"success\">   This is a success callout indicating something worked correctly. </Callout> <Callout type=\"danger\">   This is a danger callout for critical information. </Callout> <Callout type=\"tip\">This is a tip callout with helpful advice.</Callout> InfoBox Component <InfoBox type=\"info\">This is an InfoBox component (alias for Callout).</InfoBox> <InfoBox type=\"warning\" title=\"API Rate Limit\">   The API rate limit is 1000 requests per hour per API key. </InfoBox> Code Components Code Groups <CodeGroup> </CodeGroup> Code Preview Blocks <CodePreviewBlock>   <div className=\"p-4 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg text-white\">     <h3 className=\"text-xl font-bold mb-2\">Gradient Card</h3>     <p className=\"text-blue-100\">       This is a preview of a gradient card component.     </p>     <button className=\"mt-3 px-4 py-2 bg-white text-blue-600 rounded hover:bg-blue-50 transition-colors\">       Click me     </button>   </div>    </CodePreviewBlock> Individual Code Blocks Interactive Components Tabs <Tabs>   <TabsItem value=\"Overview\">     Overview          This is the overview tab with some basic information about the project.          - Feature 1: Description of the first feature     - Feature 2: Description of the second feature     - Feature 3: Description of the third feature          > This is a blockquote in the overview tab.   </TabsItem>      <TabsItem value=\"Installation\">     Installation          Install the package using your preferred package manager:                    Then import the components you need:             </TabsItem>      <TabsItem value=\"Configuration\">     Configuration          Configure the components by passing props:                    Environment Variables          Set these environment variables in your :          - : The default theme     - : The API base URL   </TabsItem> </Tabs> Layout Components Steps <Steps>   <Step>     Step 1: Project Setup          Create a new Next.js project and install the required dependencies.             </Step>      <Step>     Step 2: Configuration          Set up your configuration file and environment variables.          Create a  file in your project root:             </Step>      <Step>     Step 3: Create Content          Start creating your documentation content using MDX files.          Place your content files in the  directory and they will be automatically processed.   </Step> </Steps> Details and Summary <Details>   <Summary>Click to expand for more information</Summary>      This is additional information that can be expanded or collapsed. It's useful for:      - Hiding detailed technical information   - Creating FAQ sections   - Providing optional context       </Details> Typography and Text Headings The documentation system supports all standard heading levels with proper styling and anchor links. Inline Code Use  for short code snippets, function names, or technical terms. Code Blocks Use triple backticks for code blocks with syntax highlighting: Lists - Unordered lists work great for bullet points - They support bold text and  - And can be nested:   - Like this nested item   - And this one too 1. Ordered lists are perfect for step-by-step instructions 2. They maintain proper numbering 3. And can also be nested:    1. First nested item    2. Second nested item Blockquotes > This is a blockquote. It's great for highlighting important information, quotes, or callouts that don't need the full callout component styling. Tables | Component | Type        | Description                     | | --------- | ----------- | ------------------------------- | | Callout   | Layout      | Alert-style callouts with icons | | CodeGroup | Interactive | Tabbed code blocks              | | Tabs      | Interactive | General-purpose tabs            | | Steps     | Layout      | Step-by-step instructions       | | InfoBox   | Layout      | Alias for Callout component     | Best Practices 1. Use semantic components - Choose the right component for your content 2. Keep code blocks focused - Don't make them too long 3. Use descriptive titles - Help users understand what they're looking at 4. Test interactivity - Make sure tabs and other interactive elements work 5. Maintain consistency - Use similar patterns throughout your documentation Conclusion This showcase demonstrates all the available components in the Muni documentation system. Each component is designed to be: - Accessible - Proper ARIA attributes and keyboard navigation - Customizable - Flexible props and styling options - Consistent - Unified design language across all components - Performant - Optimized for fast loading and smooth interactions Use these components to create rich, interactive documentation that your users will love!",
    "url": "/docs/components-showcase",
    "tags": []
  },
  {
    "id": "configuration",
    "title": "Configuration",
    "content": "Configuration Muni is configured through the  file. This file contains all the settings for your documentation site. Basic Configuration Configuration Options  (required) The title of your documentation site.  (optional) The version of your documentation. Displayed in the header.  (optional) The default theme for your site. Options: , , .  (optional) Whether to show frontmatter metadata (author, date) at the bottom of pages.  (optional) Links displayed in the header next to the version.  (required) The navigation structure for your documentation.  (optional) The GitHub repository URL. Used for \"Edit on GitHub\" links. Navigation Structure The navigation supports nested items for organizing your documentation: TypeScript Types Muni exports TypeScript types for configuration: Environment Variables You can use environment variables in your configuration: Dynamic Configuration For more complex setups, you can generate configuration dynamically: Validation Muni validates your configuration at build time. Common errors: - Missing required fields - Invalid theme names - Broken navigation links - Invalid URL formats Check the build output for validation errors. Best Practices 1. Keep it simple: Don't over-complicate your navigation structure 2. Use consistent naming: Keep slug names short and descriptive 3. Group related content: Use nested navigation for organization 4. Test your links: Make sure all navigation links work 5. Version your docs: Use the version field to track changes Advanced Configuration Patterns Multi-Environment Configuration Dynamic Navigation Generation Feature Flags Type-Safe Configuration Example Configuration Here's a complete example configuration:",
    "url": "/docs/configuration",
    "tags": []
  },
  {
    "id": "deployment",
    "title": "Deployment",
    "content": "Deployment Deploy your Muni documentation to any static hosting platform. Build for Production First, build your documentation for production: This will: - Generate static HTML files - Optimize images and assets - Create a production-ready build in the  directory Deployment Platforms Vercel (Recommended) Vercel is the easiest way to deploy Next.js applications with zero configuration: 1. Connect your repository    - Push your code to GitHub    - Go to [vercel.com](https://vercel.com)    - Click \"New Project\"    - Import your repository 2. Configure build settings    - Framework: Next.js (auto-detected)    - Build Command:     - Output Directory:     - Node.js Version: 18.x or 20.x 3. Environment Variables     4. Deploy    - Vercel will automatically deploy on every push    - Your site will be available at     - Custom domains supported with automatic SSL Docker Deployment Deploy using Docker for consistent environments: 1. Create Dockerfile     2. Create .dockerignore     3. Build and run     Kubernetes Deployment Deploy to Kubernetes for scalable, production-ready hosting: 1. Create deployment.yaml     2. Create service.yaml     3. Deploy     Netlify Deploy to Netlify using the Next.js plugin: 1. Build settings     2. Deploy    - Connect your repository to Netlify    - Deploy automatically on every push GitHub Pages Deploy to GitHub Pages using GitHub Actions: 1. Create workflow file     2. Enable GitHub Pages    - Go to repository Settings > Pages    - Source: GitHub Actions    - Your site will be available at  Other Platforms Muni works with any static hosting platform: - AWS S3 + CloudFront - Cloudflare Pages - Firebase Hosting - Surge.sh - Render Environment Variables Set environment variables for production: Vercel Netlify GitHub Actions Custom Domain Vercel 1. Go to Project Settings > Domains 2. Add your custom domain 3. Update DNS records as instructed Netlify 1. Go to Site Settings > Domain Management 2. Add custom domain 3. Configure DNS settings GitHub Pages 1. Add  file to your repository:     2. Configure DNS to point to GitHub Pages Performance Optimization Image Optimization Use Next.js Image component for optimized images: Static Generation All pages are statically generated for optimal performance: Bundle Analysis Analyze your bundle size: Monitoring Analytics Add analytics to track usage: Error Monitoring Add error monitoring with Sentry: Security Content Security Policy Add CSP headers for security: HTTPS Ensure your site uses HTTPS: - Vercel: Automatic HTTPS - Netlify: Automatic HTTPS - GitHub Pages: Automatic HTTPS Troubleshooting Build Errors Common build errors and solutions: Module not found TypeScript errors Memory issues Deployment Issues 404 errors - Check if all pages are properly exported - Verify file paths and routing Styling issues - Ensure Tailwind CSS is properly configured - Check if all CSS files are included Performance issues - Use Next.js Image component - Optimize images and assets - Enable compression 2025 Best Practices Performance Optimization 1. Core Web Vitals: Ensure good LCP, FID, and CLS scores 2. Image Optimization: Use Next.js Image component with WebP/AVIF 3. Bundle Analysis: Regularly analyze and optimize bundle size 4. CDN Usage: Use global CDN for static assets 5. Caching Strategy: Implement proper caching headers 6. Code Splitting: Leverage Next.js automatic code splitting Security 1. HTTPS Everywhere: Force HTTPS redirects 2. Security Headers: Implement CSP, HSTS, and other security headers 3. Dependency Scanning: Regular security audits with  4. Environment Variables: Never commit secrets to version control 5. Access Control: Implement proper authentication if needed 6. Regular Updates: Keep all dependencies updated Monitoring & Analytics 1. Error Tracking: Use Sentry or similar for error monitoring 2. Performance Monitoring: Track Core Web Vitals 3. Uptime Monitoring: Set up uptime checks 4. Analytics: Implement privacy-friendly analytics 5. Logging: Centralized logging for debugging CI/CD Pipeline Environment Management Best Practices 1. Test locally first: Always test your build locally before deploying 2. Use environment variables: Don't hardcode sensitive information 3. Optimize images: Use appropriate formats and sizes 4. Monitor performance: Set up analytics and error monitoring 5. Keep dependencies updated: Regularly update packages for security 6. Use HTTPS: Always use HTTPS in production 7. Set up redirects: Handle old URLs and broken links 8. Backup your content: Keep your content in version control 9. Implement proper caching: Use appropriate cache headers 10. Monitor Core Web Vitals: Ensure good user experience metrics Example Deployments Vercel Netlify Manual Upload Continuous Deployment Set up automatic deployments: GitHub Actions",
    "url": "/docs/deployment",
    "tags": []
  },
  {
    "id": "getting-started",
    "title": "Getting Started",
    "content": "Getting Started This guide will help you set up Muni and create your first documentation page. Prerequisites - Node.js 18+ - pnpm (recommended) or npm Installation 1. Clone the template     2. Install dependencies     3. Start the development server     4. Open your browser    Navigate to  Project Structure Configuration Edit  to customize your documentation: Creating Pages 1. Create a new MDX file in      2. Add frontmatter (optional)     3. Write your content using Markdown     4. Add to navigation in      Writing Content Basic Markdown Muni supports standard Markdown syntax: Code Blocks Use triple backticks for code blocks: javascript function hello() {   console.log(\"Hello, world!\"); } muni.config.tspnpm buildoutmuni.config.tspnpm run generate-searchpublic/search-data.jsonpnpm devpnpm build && pnpm start` 4. Deploy to your hosting platform Next Steps - Learn about [Configuration](/configuration) - Explore [Themes](/themes) - Read about [Markdown Features](/markdown) - See [Deployment Options](/deployment)",
    "url": "/docs/getting-started",
    "tags": []
  },
  {
    "id": "index",
    "title": "Muni",
    "content": "Muni A production-ready, minimal documentation template built with Next.js 15, Tailwind CSS 4, and TypeScript. Perfect for technical documentation, API references, and developer-focused content. Why Choose Muni? Muni is designed for developers who value simplicity, performance, and maintainability. Unlike bloated documentation frameworks, Muni focuses on what matters most: clear content presentation and fast loading times. Core Philosophy Less is more - Every design decision prioritizes clarity and performance over flashy features. Muni embraces the principle that great documentation doesn't need to be complex. Key Principles - Minimal: Clean, uncluttered interface with generous whitespace - Fast: Optimized for speed with static generation and minimal JavaScript - Customizable: Simple configuration through  - Professional: Small, tight typography and spacing for a modern look - Static: No animations or shifting layouts - everything feels stable - Accessible: Built with accessibility in mind from the ground up - Type-Safe: Full TypeScript support for better developer experience Features Core Features - 3 Clean Themes: Minimal, Minimal Dark, and Mono with easy customization - Fixed-Width Content: Consistent, centered layout that doesn't shift - Small Typography: Professional 11-13px base text with tight spacing - MDX Support: Write documentation in Markdown with React components - Built-in Search: Fast, client-side search with FlexSearch - Auto-Generated TOC: Table of contents automatically generated from headings - Mobile Responsive: Clean sidebar and navigation on all devices - SEO Optimized: Proper meta tags, structured data, and sitemap Developer Experience - TypeScript: Full type safety throughout the codebase - Hot Reload: Instant updates during development - Linting: Built-in code formatting with Biome - Component Library: Pre-built components for common documentation patterns - Custom Directives: Support for custom MDX directives - Code Highlighting: Syntax highlighting with Shiki - Copy Code: One-click code copying functionality Performance - Static Generation: All pages pre-rendered for maximum speed - Image Optimization: Automatic image optimization with Next.js - Bundle Splitting: Automatic code splitting for optimal loading - CDN Ready: Optimized for global content delivery - Core Web Vitals: Optimized for Google's performance metrics Quick Start 1. Clone the repository     2. Install dependencies     3. Start development server     4. Open your browser    Navigate to  Configuration Muni is highly customizable through the  file: Themes Muni comes with three carefully crafted themes: - Minimal: Clean white background with subtle grays - Minimal Dark: Deep blacks with minimal contrast - Mono: Monospace typography for technical documentation Writing Content Create new documentation pages in the  directory as  files. Use standard Markdown syntax with support for React components. Deployment Deploy to Vercel, Netlify, or any static hosting platform: Tech Stack Frontend - Next.js 15 - React framework with App Router and static generation - Tailwind CSS 4 - Utility-first CSS framework with modern features - TypeScript - Type safety and better developer experience - React 19 - Latest React with concurrent features Content & Styling - MDX - Markdown with React components for rich content - Shiki - Syntax highlighting with 200+ language support - Lucide React - Beautiful, customizable icon library - FlexSearch - Fast, client-side search engine Development Tools - Biome - Fast linter and formatter - pnpm - Fast, disk space efficient package manager - ESLint - Code quality and consistency - Prettier - Code formatting Deployment - Vercel - Optimized for Next.js deployment - Docker - Container support for any platform - GitHub Actions - CI/CD pipeline ready License MIT License - feel free to use this template for your own projects. --- _Built with Next.js, Tailwind CSS, and a focus on simplicity._",
    "url": "/docs/index",
    "tags": []
  },
  {
    "id": "markdown",
    "title": "Markdown Features",
    "content": "Markdown Features Muni supports standard Markdown syntax with additional features for rich documentation. Basic Markdown Headings Text Formatting Lists Links and Images Code Blocks javascript function hello() {   console.log(\"Hello, world!\"); } python def hello():     print(\"Hello, world!\") titledescriptionauthordatetags Supported Languages - JavaScript/TypeScript - Python - Java - C/C++ - Go - Rust - HTML/CSS - JSON - YAML - And many more... Custom Styling Inline Styles Use Tailwind CSS classes for styling: CSS Classes You can also use custom CSS classes: Advanced Features Math Equations Use KaTeX for mathematical expressions: Diagrams Create diagrams using Mermaid: mermaid graph TD     A[Start] --> B{Decision}     B -->|Yes| C[Action 1]     B -->|No| D[Action 2]     C --> E[End]     D --> E textCode in cells~~text~~text$E = mc^2$target=\"_blank\" Endpoints GET /users Retrieve a list of users. Parameters: -  (optional): Number of users to return (default: 10) -  (optional): Number of users to skip (default: 0) Response: <InfoBox type=\"info\">   The API rate limit is 1000 requests per hour per API key. </InfoBox> `",
    "url": "/docs/markdown",
    "tags": []
  },
  {
    "id": "project-structure",
    "title": "Project Structure",
    "content": "Project Structure Understanding the Muni project structure and conventions. Directory Overview Core Files The main configuration file for your documentation: Root layout that wraps all pages: Documentation-specific layout with sidebar and navigation: Component Organization UI Components () Base components built with shadcn/ui: -  - Button component -  - Input field -  - Modal dialogs -  - Dropdown menus -  - Sidebar component -  - Tooltips -  - Alert messages -  - Badge component Navigation Components () Documentation-specific navigation: -  - Left sidebar navigation -  - Header with search and theme toggle -  - Previous/Next page navigation -  - Auto-generated TOC -  - Navigation section component Custom Components () Muni-specific components: -  - Code copy functionality -  - Step component for tutorials -  - Steps container Content Structure Documentation Pages () All documentation content as MDX files: Page Structure Each page follows this structure: Styling System Global Styles () Theme System () Three minimal themes: Configuration Files Next.js configuration with MDX support: Tailwind CSS configuration: Build System Scripts () Search Generation () Generates search index for documentation: File Naming Conventions Pages - Use kebab-case for file names:  - Use  for section homepages - Use  for dynamic routes Components - Use PascalCase for component files:  - Use kebab-case for directories:  - Use descriptive names:  Styles - Use kebab-case:  - Group related styles: ,  - Use CSS custom properties for theming Import Conventions Absolute Imports Use absolute imports with  prefix: Relative Imports Use relative imports for closely related files: Development Workflow Getting Started 1. Clone and install     2. Start development server     3. Open browser    Navigate to  Development Process 1. Create new content    - Add MDX files to     - Update navigation in     - Test locally with  2. Modify components    - Edit components in  or     - Test changes in browser    - Ensure TypeScript types are correct 3. Update styles    - Modify CSS files in     - Test in all themes    - Ensure responsive design works 4. Build and test     File Organization Guidelines 1. Components: Group by functionality    -  - Base UI components    -  - Navigation specific    -  - Muni specific 2. Content: Organize by topic    - Use descriptive filenames    - Group related content in subdirectories    - Use  for section homepages 3. Styles: Separate concerns    -  - Global styles    -  - Theme definitions    -  - Component styles Git Workflow 1. Feature branches     2. Pull requests    - Create PR for review    - Ensure all checks pass    - Merge to main after approval 3. Releases     Testing Strategy 1. Manual testing    - Test all pages in all themes    - Verify responsive design    - Check accessibility 2. Build testing     3. Linting     Best Practices Component Organization 1. Single responsibility: Each component should have one clear purpose 2. Composition over inheritance: Build complex components from simple ones 3. Props interface: Define clear TypeScript interfaces for props 4. Default exports: Use default exports for main components File Structure 1. Group by feature: Keep related files together 2. Consistent naming: Use consistent naming conventions 3. Clear hierarchy: Organize files in a logical hierarchy 4. Minimal nesting: Avoid deep directory structures Code Style 1. TypeScript: Use TypeScript for type safety 2. ESLint/Prettier: Use consistent code formatting 3. Comments: Add comments for complex logic 4. Documentation: Document public APIs Performance 1. Code splitting: Use dynamic imports for large components 2. Image optimization: Use Next.js Image component 3. Bundle analysis: Regularly analyze bundle size 4. Static generation: Prefer static generation over SSR Adding New Features New Page 1. Create MDX file in  2. Add to navigation in  3. Test the page locally New Component 1. Create component file in appropriate directory 2. Export from component file 3. Import and use in pages/components 4. Add TypeScript types if needed New Theme 1. Add theme class to  2. Update theme types in  3. Add theme option to theme toggle 4. Test theme across all pages Troubleshooting Common Issues Build errors - Check TypeScript types - Verify import paths - Check for missing dependencies Styling issues - Verify Tailwind classes - Check CSS custom properties - Ensure proper theme classes Navigation issues - Check slug format in config - Verify file paths - Test internal links Performance issues - Analyze bundle size - Check for large images - Optimize imports",
    "url": "/docs/project-structure",
    "tags": []
  },
  {
    "id": "themes",
    "title": "Themes",
    "content": "Themes Muni comes with three carefully crafted themes designed for minimal, professional documentation. Available Themes Minimal (Light) The default theme with a clean white background and subtle grays. - Background: Pure white - Text: Dark gray with minimal contrast - Accents: Subtle gray borders and highlights - Typography: Sans-serif (Geist Sans) Perfect for general documentation and clean, modern looks. Minimal Dark A dark theme with deep blacks and minimal contrast. - Background: Deep black - Text: Light gray with high contrast - Accents: Subtle borders and highlights - Typography: Sans-serif (Geist Sans) Ideal for dark mode users and technical documentation. Mono A monospace theme inspired by terminal interfaces. - Background: Light gray - Text: Dark gray with monospace font - Accents: Clean borders and minimal styling - Typography: Monospace (Geist Mono) Perfect for technical documentation, code references, and developer-focused content. Setting the Theme Default Theme Set the default theme in : Theme Toggle Users can switch themes using the theme toggle in the header. The toggle cycles through: 1. Minimal (Light) 2. Minimal Dark 3. Mono 4. System (follows OS preference) Theme Customization CSS Variables Each theme defines CSS variables that you can override: Custom Theme To create a custom theme: 1. Add theme class to : 2. Update theme toggle to include your theme: 3. Update TypeScript types: Design Principles All Muni themes follow these design principles: Minimalism - Clean, uncluttered interfaces - Generous whitespace - Subtle colors and borders - No unnecessary visual elements Typography - Small, readable text (11-13px base) - Tight line heights for professional look - Consistent font weights - Proper hierarchy Spacing - Consistent spacing scale - Tight padding and margins - Generous whitespace between sections - No excessive padding Colors - High contrast for readability - Subtle accent colors - Consistent color relationships - Accessible color combinations Theme Variables Core Colors Semantic Colors Status Colors UI Colors Sidebar Colors Practical Customization Examples Creating a Brand Theme Create a custom theme that matches your brand colors: Dark Mode with Custom Colors High Contrast Theme Theme Switching Implementation Update your theme toggle component: CSS Custom Properties Reference Complete list of available CSS custom properties: Best Practices 1. Test all themes: Ensure your content looks good in all themes 2. Use semantic colors: Use  instead of hardcoded colors 3. Maintain contrast: Ensure text is readable in all themes 4. Keep it minimal: Don't over-customize - embrace the minimal aesthetic 5. Test accessibility: Ensure color combinations meet accessibility standards 6. Use OKLCH colors: Better color interpolation and consistency 7. Test in different lighting: Check themes in various lighting conditions 8. Consider color blindness: Ensure themes work for colorblind users 9. Document your themes: Keep a reference of your custom themes 10. Version your themes: Track changes to your theme definitions Examples Minimal Theme Minimal Dark Theme Mono Theme",
    "url": "/docs/themes",
    "tags": []
  }
]