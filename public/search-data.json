[
  {
    "id": "api/built-in-components",
    "title": "Built-in Components Reference",
    "content": "Built-in Components [The Toolbox] Muni provides a set of powerful components that are globally available in all your MDX files. These are designed to help you create rich, structured content without needing to import them. Callouts Callouts are used to highlight a block of text. They are created using the  container directive. - Directive:  - Supported Types: , , ,  Steps The  component creates an ordered, numbered list of steps, perfect for tutorials. It automatically numbers any  heading within it. - Directive:  CodeGroup A component for displaying multiple code blocks in a tabbed view. - Directive:  ts [TypeScript] const message: string = \"Hello\"; js [JavaScript] const message = \"Hello\"; Aside<Aside>",
    "url": "/docs/api/built-in-components",
    "tags": []
  },
  {
    "id": "api/configuration",
    "title": "Configuration Reference",
    "content": "Configuration [The Control Panel] Configuration for a Muni project is handled in two main places:  for site-specific settings like navigation, and  for the underlying MDX and Next.js behavior. This is the primary configuration file for your site's content and navigation. It exports a  object.  Interface - Type:  - Description: The main title of your documentation site. It's used in the browser tab, metadata, and can be used in your site header. - Type:  (optional) - Description: A version string for your project, which is displayed in the site header. - Type:  (optional) - Default:  - Description: Whether to display the author and date from the frontmatter at the bottom of each page. - Type:  (optional) - Description: An array of link objects to be displayed in the site header, next to the version. - Type:  - Description: An array of objects that defines the structure of your sidebar navigation. Each  has the following properties: -  (string): The text displayed in the navigation sidebar. -  (string): The URL slug for the page. This must match the file path in  (without the  extension). For the homepage, use . -  (optional ): An optional array of nested navigation items to create collapsible sections in the sidebar. Example Configuration This file controls the Next.js build process, including how MDX files are handled. Muni comes with a pre-configured set of Remark and Rehype plugins to add advanced features to your Markdown. Default Plugins Muni's default configuration includes plugins for: - GFM (GitHub Flavored Markdown): Adds support for tables, strikethroughs, etc. - Frontmatter: Parses the YAML frontmatter from your files. - Code Block Titles: Adds titles to code blocks. - Callouts: Enables  directives for callouts. - Steps: Enables the  component. - Slug & Autolink Headings: Automatically adds s to headings and links them. Customizing Plugins You can add your own Remark or Rehype plugins by modifying the  object in .",
    "url": "/docs/api/configuration",
    "tags": []
  },
  {
    "id": "api/frontmatter",
    "title": "Frontmatter Reference",
    "content": "Frontmatter Reference [Page Metadata] Frontmatter is the YAML block at the top of your MDX files, enclosed by triple dashes (). It allows you to provide metadata for each page. Standard Properties These are the primary properties that Muni uses to control page rendering and SEO. -   Type:  -   Required:  -   Description: The main title of the page. It is displayed at the top of the page content and used in the browser tab title (). -   Type:  -   Required:  -   Description: A brief summary of the page content. This is critical for SEO as it is used for the  tag, and it also powers the text snippets in the site's search results. Custom Properties You can add any other custom properties to your frontmatter. These properties are not used by Muni out-of-the-box, but they can be accessed from your own custom components or during the build process. Example with Custom Metadata Accessing Custom Frontmatter While Muni doesn't use custom frontmatter directly, you can configure your project to read it. For example, you could create a custom component that reads the  and  from the page's frontmatter. This typically requires customizing the MDX loader or creating a wrapper component that has access to the page's metadata. The frontmatter is available to the page layout component.",
    "url": "/docs/api/frontmatter",
    "tags": []
  },
  {
    "id": "api",
    "title": "API Reference",
    "content": "API Reference [Technical Details] This section provides a detailed technical reference for the key APIs and configuration surfaces in Muni. Use these guides to understand all the available options for customizing and extending your documentation site. Reference Documents <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\"> <a href=\"/docs/api/configuration\" className=\"border p-4 rounded-lg hover:bg-accent\">   <h3 class=\"font-semibold text-lg mb-2\">Configuration</h3>   <p class=\"text-sm text-muted-foreground\">Explore all the options available in the  and  files.</p> </a> <a href=\"/docs/api/frontmatter\" className=\"border p-4 rounded-lg hover:bg-accent\">   <h3 class=\"font-semibold text-lg mb-2\">Frontmatter</h3>   <p class=\"text-sm text-muted-foreground\">A complete reference for all the standard and custom frontmatter properties you can use in your MDX files.</p> </a> <a href=\"/docs/api/built-in-components\" className=\"border p-4 rounded-lg hover:bg-accent\">   <h3 class=\"font-semibold text-lg mb-2\">Built-in Components</h3>   <p class=\"text-sm text-muted-foreground\">A detailed look at the props and usage of all the globally available components like  and .</p> </a> </div>",
    "url": "/docs/api",
    "tags": []
  },
  {
    "id": "component-showcase",
    "title": "Component Showcase",
    "content": "Component Showcase Simple examples of available MDX components for documentation. Callouts <Callout type=\"info\">Information callout with default styling.</Callout> <Callout type=\"warning\" title=\"Warning\">   Warning callout with custom title. </Callout> <Callout type=\"success\">Success callout for positive feedback.</Callout> Code Groups <CodeGroup> </CodeGroup> Code Preview <CodePreviewBlock>   <div className=\"p-4 bg-blue-50 rounded border\">     <h3 className=\"font-semibold text-blue-900\">Preview</h3>     <p className=\"text-blue-700\">Live component preview</p>   </div>    </CodePreviewBlock> Steps <Steps>   Install   Install the package using your preferred manager. Configure Create a config file. Deploy Build and deploy your site. </Steps> Tabs <Tabs>   <TabsItem value=\"overview\">     Overview Basic information about the feature.   </TabsItem>   <TabsItem value=\"api\">API Technical details and endpoints.</TabsItem>   <TabsItem value=\"examples\">Examples Practical usage examples.</TabsItem> </Tabs> InfoBox <InfoBox type=\"info\">Additional context and information.</InfoBox> <InfoBox type=\"warning\" title=\"Beta\">   This feature is currently in beta. </InfoBox>",
    "url": "/docs/component-showcase",
    "tags": []
  },
  {
    "id": "configuration",
    "title": "Configuration",
    "content": "Configuration Muni is configured through the  file. This file contains all the settings for your documentation site. Basic Configuration Configuration Options  (required) The title of your documentation site.  (optional) The version of your documentation. Displayed in the header.  (optional) The default theme for your site. Options: , , .  (optional) Whether to show frontmatter metadata (author, date) at the bottom of pages.  (optional) Links displayed in the header next to the version.  (required) The navigation structure for your documentation.  (optional) The GitHub repository URL. Used for \"Edit on GitHub\" links. Navigation Structure The navigation supports nested items for organizing your documentation: TypeScript Types Muni exports TypeScript types for configuration: Environment Variables You can use environment variables in your configuration: Dynamic Configuration For more complex setups, you can generate configuration dynamically: Validation Muni validates your configuration at build time. Common errors: - Missing required fields - Invalid theme names - Broken navigation links - Invalid URL formats Check the build output for validation errors. Best Practices 1. Keep it simple: Don't over-complicate your navigation structure 2. Use consistent naming: Keep slug names short and descriptive 3. Group related content: Use nested navigation for organization 4. Test your links: Make sure all navigation links work 5. Version your docs: Use the version field to track changes Example Configuration Here's a complete example configuration:",
    "url": "/docs/configuration",
    "tags": []
  },
  {
    "id": "deployment",
    "title": "Deployment",
    "content": "Deployment Deploy your Muni documentation to any static hosting platform. Build for Production First, build your documentation for production: This will: - Generate static HTML files - Optimize images and assets - Create a production-ready build in the  directory Deployment Platforms Vercel (Recommended) Vercel is the easiest way to deploy Next.js applications: 1. Connect your repository    - Push your code to GitHub    - Go to [vercel.com](https://vercel.com)    - Click \"New Project\"    - Import your repository 2. Configure build settings    - Framework: Next.js    - Build Command:     - Output Directory:  3. Deploy    - Vercel will automatically deploy on every push    - Your site will be available at  Netlify Deploy to Netlify using the Next.js plugin: 1. Build settings     2. Deploy    - Connect your repository to Netlify    - Deploy automatically on every push GitHub Pages Deploy to GitHub Pages using GitHub Actions: 1. Create workflow file     2. Enable GitHub Pages    - Go to repository Settings > Pages    - Source: GitHub Actions    - Your site will be available at  Other Platforms Muni works with any static hosting platform: - AWS S3 + CloudFront - Cloudflare Pages - Firebase Hosting - Surge.sh - Render Environment Variables Set environment variables for production: Vercel Netlify GitHub Actions Custom Domain Vercel 1. Go to Project Settings > Domains 2. Add your custom domain 3. Update DNS records as instructed Netlify 1. Go to Site Settings > Domain Management 2. Add custom domain 3. Configure DNS settings GitHub Pages 1. Add  file to your repository:     2. Configure DNS to point to GitHub Pages Performance Optimization Image Optimization Use Next.js Image component for optimized images: Static Generation All pages are statically generated for optimal performance: Bundle Analysis Analyze your bundle size: Monitoring Analytics Add analytics to track usage: Error Monitoring Add error monitoring with Sentry: Security Content Security Policy Add CSP headers for security: HTTPS Ensure your site uses HTTPS: - Vercel: Automatic HTTPS - Netlify: Automatic HTTPS - GitHub Pages: Automatic HTTPS Troubleshooting Build Errors Common build errors and solutions: Module not found TypeScript errors Memory issues Deployment Issues 404 errors - Check if all pages are properly exported - Verify file paths and routing Styling issues - Ensure Tailwind CSS is properly configured - Check if all CSS files are included Performance issues - Use Next.js Image component - Optimize images and assets - Enable compression Best Practices 1. Test locally first: Always test your build locally before deploying 2. Use environment variables: Don't hardcode sensitive information 3. Optimize images: Use appropriate formats and sizes 4. Monitor performance: Set up analytics and error monitoring 5. Keep dependencies updated: Regularly update packages for security 6. Use HTTPS: Always use HTTPS in production 7. Set up redirects: Handle old URLs and broken links 8. Backup your content: Keep your content in version control Example Deployments Vercel Netlify Manual Upload Continuous Deployment Set up automatic deployments: GitHub Actions",
    "url": "/docs/deployment",
    "tags": []
  },
  {
    "id": "getting-started",
    "title": "Getting Started",
    "content": "Getting Started This guide will help you set up Muni and create your first documentation page. Prerequisites - Node.js 18+ - pnpm (recommended) or npm Installation 1. Clone the template     2. Install dependencies     3. Start the development server     4. Open your browser    Navigate to  Project Structure Configuration Edit  to customize your documentation: Creating Pages 1. Create a new MDX file in      2. Add frontmatter (optional)     3. Write your content using Markdown     4. Add to navigation in      Writing Content Basic Markdown Muni supports standard Markdown syntax: Code Blocks Use triple backticks for code blocks: javascript function hello() {   console.log(\"Hello, world!\"); } muni.config.tspnpm buildout` directory to Netlify Other Platforms Any static hosting platform that supports Next.js will work. Next Steps - Learn about [Configuration](/configuration) - Explore [Themes](/themes) - Read about [Markdown Features](/markdown) - See [Deployment Options](/deployment)",
    "url": "/docs/getting-started",
    "tags": []
  },
  {
    "id": "index",
    "title": "Muni",
    "content": "Muni A minimal, fast documentation template built with Next.js and Tailwind CSS. Philosophy Muni is designed around the principle of less is more. Every component, every line of code, every design decision is made with simplicity and performance in mind. Key Principles - Minimal: Clean, uncluttered interface with generous whitespace - Fast: Optimized for speed with static generation and minimal JavaScript - Customizable: Simple configuration through  - Professional: Small, tight typography and spacing for a modern look - Static: No animations or shifting layouts - everything feels stable Features - 3 Clean Themes: Minimal, Minimal Dark, and Mono - Fixed-Width Content: Consistent, centered layout that doesn't shift - Small Typography: Professional 11-13px base text with tight spacing - MDX Support: Write documentation in Markdown with React components - Search: Built-in search functionality - Table of Contents: Auto-generated from headings - Mobile Responsive: Clean sidebar on mobile devices - SEO Optimized: Proper meta tags and structured data Quick Start 1. Clone the repository     2. Install dependencies     3. Start development server     4. Open your browser    Navigate to  Configuration Muni is highly customizable through the  file: Themes Muni comes with three carefully crafted themes: - Minimal: Clean white background with subtle grays - Minimal Dark: Deep blacks with minimal contrast - Mono: Monospace typography for technical documentation Writing Content Create new documentation pages in the  directory as  files. Use standard Markdown syntax with support for React components. Deployment Deploy to Vercel, Netlify, or any static hosting platform: License MIT License - feel free to use this template for your own projects. --- _Built with Next.js, Tailwind CSS, and a focus on simplicity._",
    "url": "/docs/index",
    "tags": []
  },
  {
    "id": "markdown",
    "title": "Markdown Features",
    "content": "Markdown Features Muni supports standard Markdown syntax with additional features for rich documentation. Basic Markdown Headings Text Formatting Lists Links and Images Code Blocks javascript function hello() {   console.log(\"Hello, world!\"); } python def hello():     print(\"Hello, world!\") titledescriptionauthordatetags Supported Languages - JavaScript/TypeScript - Python - Java - C/C++ - Go - Rust - HTML/CSS - JSON - YAML - And many more... Custom Styling Inline Styles Use Tailwind CSS classes for styling: CSS Classes You can also use custom CSS classes: Advanced Features Math Equations Use KaTeX for mathematical expressions: Diagrams Create diagrams using Mermaid: mermaid graph TD     A[Start] --> B{Decision}     B -->|Yes| C[Action 1]     B -->|No| D[Action 2]     C --> E[End]     D --> E target=\"_blank\" Endpoints GET /users Retrieve a list of users. Parameters: -  (optional): Number of users to return (default: 10) -  (optional): Number of users to skip (default: 0) Response: <InfoBox type=\"info\">   The API rate limit is 1000 requests per hour per API key. </InfoBox> `",
    "url": "/docs/markdown",
    "tags": []
  },
  {
    "id": "project-structure",
    "title": "Project Structure",
    "content": "Project Structure Understanding the Muni project structure and conventions. Directory Overview Core Files The main configuration file for your documentation: Root layout that wraps all pages: Documentation-specific layout with sidebar and navigation: Component Organization UI Components () Base components built with shadcn/ui: -  - Button component -  - Input field -  - Modal dialogs -  - Dropdown menus -  - Sidebar component -  - Tooltips -  - Alert messages -  - Badge component Navigation Components () Documentation-specific navigation: -  - Left sidebar navigation -  - Header with search and theme toggle -  - Previous/Next page navigation -  - Auto-generated TOC -  - Navigation section component Custom Components () Muni-specific components: -  - Code copy functionality -  - Step component for tutorials -  - Steps container Content Structure Documentation Pages () All documentation content as MDX files: Page Structure Each page follows this structure: Styling System Global Styles () Theme System () Three minimal themes: Configuration Files Next.js configuration with MDX support: Tailwind CSS configuration: Build System Scripts () Search Generation () Generates search index for documentation: File Naming Conventions Pages - Use kebab-case for file names:  - Use  for section homepages - Use  for dynamic routes Components - Use PascalCase for component files:  - Use kebab-case for directories:  - Use descriptive names:  Styles - Use kebab-case:  - Group related styles: ,  - Use CSS custom properties for theming Import Conventions Absolute Imports Use absolute imports with  prefix: Relative Imports Use relative imports for closely related files: Best Practices Component Organization 1. Single responsibility: Each component should have one clear purpose 2. Composition over inheritance: Build complex components from simple ones 3. Props interface: Define clear TypeScript interfaces for props 4. Default exports: Use default exports for main components File Structure 1. Group by feature: Keep related files together 2. Consistent naming: Use consistent naming conventions 3. Clear hierarchy: Organize files in a logical hierarchy 4. Minimal nesting: Avoid deep directory structures Code Style 1. TypeScript: Use TypeScript for type safety 2. ESLint/Prettier: Use consistent code formatting 3. Comments: Add comments for complex logic 4. Documentation: Document public APIs Performance 1. Code splitting: Use dynamic imports for large components 2. Image optimization: Use Next.js Image component 3. Bundle analysis: Regularly analyze bundle size 4. Static generation: Prefer static generation over SSR Adding New Features New Page 1. Create MDX file in  2. Add to navigation in  3. Test the page locally New Component 1. Create component file in appropriate directory 2. Export from component file 3. Import and use in pages/components 4. Add TypeScript types if needed New Theme 1. Add theme class to  2. Update theme types in  3. Add theme option to theme toggle 4. Test theme across all pages Troubleshooting Common Issues Build errors - Check TypeScript types - Verify import paths - Check for missing dependencies Styling issues - Verify Tailwind classes - Check CSS custom properties - Ensure proper theme classes Navigation issues - Check slug format in config - Verify file paths - Test internal links Performance issues - Analyze bundle size - Check for large images - Optimize imports",
    "url": "/docs/project-structure",
    "tags": []
  },
  {
    "id": "test-components",
    "title": "Component Test",
    "content": "Component Test This page tests all MDX components to ensure they work correctly. Code Groups Test <CodeGroup> </CodeGroup> Code Preview Test <CodePreviewBlock>   <div className=\"p-4 bg-green-100 rounded\">     <h3 className=\"text-green-800\">Test Preview</h3>     <p className=\"text-green-600\">This should work!</p>   </div>    </CodePreviewBlock> Tabs Test <Tabs>   <TabsItem value=\"first\">     First Tab This is the first tab content with bold text and . - List item 1 - List item 2   </TabsItem>   <TabsItem value=\"second\">     Second Tab This is the second tab with more content.    </TabsItem>   <TabsItem value=\"third\">     Third Tab This is the third tab with even more content. > This is a     blockquote in the third tab.   </TabsItem> </Tabs> Callouts Test <Callout type=\"info\">This is an info callout for testing.</Callout> <Callout type=\"warning\" title=\"Warning\">   This is a warning callout for testing. </Callout> <Callout type=\"success\">This is a success callout for testing.</Callout> InfoBox Test <InfoBox type=\"info\">This is an InfoBox for testing.</InfoBox> <InfoBox type=\"warning\" title=\"Beta\">   This is a warning InfoBox for testing. </InfoBox>",
    "url": "/docs/test-components",
    "tags": []
  },
  {
    "id": "themes",
    "title": "Themes",
    "content": "Themes Muni comes with three carefully crafted themes designed for minimal, professional documentation. Available Themes Minimal (Light) The default theme with a clean white background and subtle grays. - Background: Pure white - Text: Dark gray with minimal contrast - Accents: Subtle gray borders and highlights - Typography: Sans-serif (Geist Sans) Perfect for general documentation and clean, modern looks. Minimal Dark A dark theme with deep blacks and minimal contrast. - Background: Deep black - Text: Light gray with high contrast - Accents: Subtle borders and highlights - Typography: Sans-serif (Geist Sans) Ideal for dark mode users and technical documentation. Mono A monospace theme inspired by terminal interfaces. - Background: Light gray - Text: Dark gray with monospace font - Accents: Clean borders and minimal styling - Typography: Monospace (Geist Mono) Perfect for technical documentation, code references, and developer-focused content. Setting the Theme Default Theme Set the default theme in : Theme Toggle Users can switch themes using the theme toggle in the header. The toggle cycles through: 1. Minimal (Light) 2. Minimal Dark 3. Mono 4. System (follows OS preference) Theme Customization CSS Variables Each theme defines CSS variables that you can override: Custom Theme To create a custom theme: 1. Add theme class to : 2. Update theme toggle to include your theme: 3. Update TypeScript types: Design Principles All Muni themes follow these design principles: Minimalism - Clean, uncluttered interfaces - Generous whitespace - Subtle colors and borders - No unnecessary visual elements Typography - Small, readable text (11-13px base) - Tight line heights for professional look - Consistent font weights - Proper hierarchy Spacing - Consistent spacing scale - Tight padding and margins - Generous whitespace between sections - No excessive padding Colors - High contrast for readability - Subtle accent colors - Consistent color relationships - Accessible color combinations Theme Variables Core Colors Semantic Colors Status Colors UI Colors Sidebar Colors Best Practices 1. Test all themes: Ensure your content looks good in all themes 2. Use semantic colors: Use  instead of hardcoded colors 3. Maintain contrast: Ensure text is readable in all themes 4. Keep it minimal: Don't over-customize - embrace the minimal aesthetic 5. Test accessibility: Ensure color combinations meet accessibility standards Examples Minimal Theme Minimal Dark Theme Mono Theme",
    "url": "/docs/themes",
    "tags": []
  }
]